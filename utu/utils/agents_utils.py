import json
import uuid
from collections.abc import AsyncIterator
from typing import Literal

from openai import AsyncOpenAI
from openai.types.responses import ResponseFunctionToolCall

from agents import (
    HandoffOutputItem,
    ItemHelpers,
    MessageOutputItem,
    OpenAIChatCompletionsModel,
    RunItem,
    StreamEvent,
    ToolCallItem,
    ToolCallOutputItem,
)
from agents.stream_events import AgentUpdatedStreamEvent, RawResponsesStreamEvent, RunItemStreamEvent
from utu.utils.print_utils import PrintUtils


class AgentsUtils:
    @staticmethod
    def generate_group_id() -> str:
        """Generate a unique group ID. (Used in OpenAI tracing)
        Ref: https://openai.github.io/openai-agents-python/tracing/
        """
        return uuid.uuid4().hex[:16]

    @staticmethod
    def get_agents_model(
        model: str,
        api_key: str = None,
        base_url: str = None,
        # mode: Literal["responses", "chat.completions"] = "chat.completions",
    ) -> OpenAIChatCompletionsModel:
        openai_client = AsyncOpenAI(api_key=api_key, base_url=base_url)
        return OpenAIChatCompletionsModel(model=model, openai_client=openai_client)

    @staticmethod
    def print_new_items(new_items: list[RunItem]) -> None:
        """Print new items generated by Runner.run()"""
        for new_item in new_items:
            agent_name = new_item.agent.name
            if isinstance(new_item, MessageOutputItem):
                PrintUtils.print_bot(f"{agent_name}: {ItemHelpers.text_message_output(new_item)}")
            elif isinstance(new_item, HandoffOutputItem):
                PrintUtils.print_info(f"Handed off from {new_item.source_agent.name} to {new_item.target_agent.name}")
            elif isinstance(new_item, ToolCallItem):
                assert isinstance(new_item.raw_item, ResponseFunctionToolCall)  # DONOT use openai's built-in tools
                PrintUtils.print_info(
                    f"{agent_name}: Calling a tool: {new_item.raw_item.name}({json.loads(new_item.raw_item.arguments)})"  # node that API always return the json string
                )
            elif isinstance(new_item, ToolCallOutputItem):
                PrintUtils.print_tool(f"Tool call output: {new_item.output}")
            else:
                PrintUtils.print_info(f"{agent_name}: Skipping item: {new_item.__class__.__name__}")

    @staticmethod
    async def print_stream_events(result: AsyncIterator[StreamEvent]) -> None:
        """Print stream events generated by Runner.run_streamed()"""
        async for event in result:
            if isinstance(event, RawResponsesStreamEvent):
                # event.data -- ResponseStreamEvent
                if event.data.type == "response.output_text.delta":
                    PrintUtils.print_info(f"{event.data.delta}", end="")
                elif event.data.type in ("response.output_text.done",):
                    PrintUtils.print_info("")
                elif event.data.type in (
                    "response.created", "response.completed", "response.in_progress",
                    "response.content_part.added", "response.content_part.done"
                    "response.output_item.added", "response.output_item.done",
                    "response.function_call_arguments.delta", "response.function_call_arguments.done",
                ):
                    pass
            elif isinstance(event, RunItemStreamEvent):
                item: RunItem = event.item
                if item.type == "message_output_item":
                    PrintUtils.print_bot(f"<{item.agent.name}> {ItemHelpers.text_message_output(item).strip()}")
                # elif item.type == "handoff_call_item":  # same as `ToolCallItem`
                #     PrintUtils.print_bot(f"<{item.agent.name}> [handoff_call] {item.raw_item.name}({item.raw_item.arguments})")
                # elif item.type == "handoff_output_item":
                #     PrintUtils.print_info(f">> Handoff from {item.source_agent.name} to {item.target_agent.name}")
                elif item.type == "tool_call_item":
                    PrintUtils.print_bot(f"<{item.agent.name}> [tool_call] {item.raw_item.name}({item.raw_item.arguments})")
                elif item.type == "tool_call_output_item":
                    PrintUtils.print_tool(f"<{item.agent.name}> [tool_output] {item.raw_item.output}")  # item.output may not by str!
                else:
                    assert event.type in ("reasoning_item", "mcp_list_tools_item", "mcp_approval_request_item", "mcp_approval_response_item")
                    PrintUtils.print_info(f"  >>> Skipping item: {item.__class__.__name__}")
            elif isinstance(event, AgentUpdatedStreamEvent):
                PrintUtils.print_info(f">> new agent: {event.new_agent.name}")
        print()  # Newline after stream?